<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Routines · GeometricMachineLearning.jl</title><meta name="title" content="Routines · GeometricMachineLearning.jl"/><meta property="og:title" content="Routines · GeometricMachineLearning.jl"/><meta property="twitter:title" content="Routines · GeometricMachineLearning.jl"/><meta name="description" content="Documentation for GeometricMachineLearning.jl."/><meta property="og:description" content="Documentation for GeometricMachineLearning.jl."/><meta property="twitter:description" content="Documentation for GeometricMachineLearning.jl."/><meta property="og:url" content="https://juliagni.github.io/GeometricMachineLearning.jl/data_loader/data_loader/"/><meta property="twitter:url" content="https://juliagni.github.io/GeometricMachineLearning.jl/data_loader/data_loader/"/><link rel="canonical" href="https://juliagni.github.io/GeometricMachineLearning.jl/data_loader/data_loader/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="GeometricMachineLearning.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="GeometricMachineLearning.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Architectures</span><ul><li><a class="tocitem" href="../../architectures/sympnet/">SympNet</a></li></ul></li><li><span class="tocitem">Manifolds</span><ul><li><a class="tocitem" href="../../manifolds/basic_topology/">Concepts from General Topology</a></li><li><a class="tocitem" href="../../manifolds/manifolds/">General Theory on Manifolds</a></li><li><a class="tocitem" href="../../manifolds/inverse_function_theorem/">The Inverse Function Theorem</a></li><li><a class="tocitem" href="../../manifolds/submersion_theorem/">The Submersion Theorem</a></li><li><a class="tocitem" href="../../manifolds/homogeneous_spaces/">Homogeneous Spaces</a></li><li><a class="tocitem" href="../../manifolds/stiefel_manifold/">Stiefel</a></li><li><a class="tocitem" href="../../manifolds/grassmann_manifold/">Grassmann</a></li><li><a class="tocitem" href="../../manifolds/existence_and_uniqueness_theorem/">Differential Equations and the EAU theorem</a></li></ul></li><li><span class="tocitem">Arrays</span><ul><li><a class="tocitem" href="../../arrays/stiefel_lie_alg_horizontal/">Stiefel Global Tangent Space</a></li><li><a class="tocitem" href="../../arrays/grassmann_lie_alg_hor_matrix/">Grassmann Global Tangent Space</a></li></ul></li><li><span class="tocitem">Optimizer Framework</span><ul><li><a class="tocitem" href="../../Optimizer/">Optimizers</a></li><li><a class="tocitem" href="../../optimizers/general_optimization/">General Optimization</a></li></ul></li><li><span class="tocitem">Optimizer Functions</span><ul><li><a class="tocitem" href="../../optimizers/manifold_related/horizontal_lift/">Horizontal Lift</a></li><li><a class="tocitem" href="../../optimizers/manifold_related/global_sections/">Global Sections</a></li><li><a class="tocitem" href="../../optimizers/manifold_related/retractions/">Retractions</a></li><li><a class="tocitem" href="../../optimizers/manifold_related/geodesic/">Geodesic Retraction</a></li><li><a class="tocitem" href="../../optimizers/manifold_related/cayley/">Cayley Retraction</a></li><li><a class="tocitem" href="../../optimizers/adam_optimizer/">Adam Optimizer</a></li><li><a class="tocitem" href="../../optimizers/bfgs_optimizer/">BFGS Optimizer</a></li></ul></li><li><span class="tocitem">Special Neural Network Layers</span><ul><li><a class="tocitem" href="../../layers/attention_layer/">Attention</a></li><li><a class="tocitem" href="../../layers/multihead_attention_layer/">Multihead Attention</a></li></ul></li><li><span class="tocitem">Data Loader</span><ul><li class="is-active"><a class="tocitem" href>Routines</a><ul class="internal"><li><a class="tocitem" href="#Convenience-functions"><span>Convenience functions</span></a></li><li><a class="tocitem" href="#Sampling-from-a-tensor"><span>Sampling from a tensor</span></a></li></ul></li><li><a class="tocitem" href="../snapshot_matrix/">Snapshot matrix &amp; tensor</a></li></ul></li><li><span class="tocitem">Reduced Order Modelling</span><ul><li><a class="tocitem" href="../../reduced_order_modeling/autoencoder/">POD and Autoencoders</a></li><li><a class="tocitem" href="../../reduced_order_modeling/symplectic_autoencoder/">PSD and Symplectic Autoencoders</a></li><li><a class="tocitem" href="../../reduced_order_modeling/kolmogorov_n_width/">Kolmogorov n-width</a></li><li><a class="tocitem" href="../../reduced_order_modeling/projection_reduction_errors/">Projection and Reduction Error</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/sympnet_tutorial/">Sympnets</a></li><li><a class="tocitem" href="../../tutorials/linear_wave_equation/">Linear Wave Equation</a></li><li><a class="tocitem" href="../../tutorials/mnist_tutorial/">MNIST</a></li><li><a class="tocitem" href="../../tutorials/grassmann_layer/">Grassmann manifold</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Data Loader</a></li><li class="is-active"><a href>Routines</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Routines</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGNI/GeometricMachineLearning.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGNI/GeometricMachineLearning.jl/blob/main/docs/src/data_loader/data_loader.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-Loader"><a class="docs-heading-anchor" href="#Data-Loader">Data Loader</a><a id="Data-Loader-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Loader" title="Permalink"></a></h1><p>Data Loader is a struct that creates an instance based on a tensor (or different input format) and is designed to make training convenient. </p><p>The fields of the struct are the following: </p><ul><li><code>data</code>: The input data with axes (i) system dimension, (ii) number of parameters and (iii) number of time steps.</li><li><code>output</code>: The tensor that contains the output (supervised learning) - this may be of type Nothing if the constructor is only called with one tensor (unsupervised learning).</li><li><code>input_dim</code>: The <em>dimension</em> of the system, i.e. what is taken as input by a regular neural network.</li><li><code>input_time_steps</code>: The length of the entire time series of the data</li><li><code>n_params</code>: The number of parameters that are present in the data set (length of third axis)</li><li><code>output_dim</code>: The dimension of the output tensor (first axis). </li><li><code>output_time_steps</code>: The size of the second axis of the output tensor (also called <code>prediction_window</code>, <code>output_time_steps=1</code> in most cases)</li></ul><p>If for the output we have a tensor whose second axis has length 1, we still store it as a tensor and not a matrix for consistency. </p><p>The data loader can be called with various types of arrays as input, for example a <a href="../snapshot_matrix/">snapshot matrix</a>:</p><pre><code class="language-julia hljs">using GeometricMachineLearning # hide

SnapshotMatrix = rand(Float32, 10, 100)

dl = DataLoader(SnapshotMatrix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataLoader{Float32, Matrix{Float32}, Nothing, GeometricMachineLearning.RegularData}(Float32[0.026135623 0.59938294 … 0.061642826 0.6343076; 0.28643185 0.9401097 … 0.8999408 0.88313836; … ; 0.82771784 0.42363447 … 0.27095544 0.98160094; 0.5191271 0.4588679 … 0.0076836944 0.8309759], nothing, 10, nothing, 100, nothing, nothing)</code></pre><p>or a snapshot tensor: </p><pre><code class="language-julia hljs">using GeometricMachineLearning # hide

SnapshotTensor = rand(Float32, 10, 100, 5)

dl = DataLoader(SnapshotTensor)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataLoader{Float32, Array{Float32, 3}, Nothing, GeometricMachineLearning.TimeSteps}(Float32[0.28377867 0.157592 … 0.7238921 0.4843762; 0.54831964 0.80572176 … 0.6390587 0.9424096; … ; 0.03541398 0.7345692 … 0.626573 0.39722097; 0.971286 0.2694704 … 0.62429225 0.65285784;;; 0.6582689 0.41900033 … 0.8406594 0.61653364; 0.6971849 0.8373756 … 0.68430024 0.72480667; … ; 0.29863656 0.8910453 … 0.89099807 0.7110597; 0.75825393 0.050382078 … 0.8393244 0.21233517;;; 0.4549511 0.280599 … 0.42240918 0.039077044; 0.109864056 0.4220327 … 0.07110071 0.39419478; … ; 0.8465499 0.5768888 … 0.98504245 0.40540397; 0.5501031 0.45637465 … 0.75314075 0.7872846;;; 0.876544 0.05632013 … 0.36926246 0.10390407; 0.7154651 0.9169866 … 0.39329696 0.6341181; … ; 0.83823246 0.12115747 … 0.2193535 0.09735042; 0.35365742 0.100767255 … 0.33377796 0.17554897;;; 0.4438209 0.06586659 … 0.70048356 0.7854638; 0.7828962 0.7452919 … 0.40805304 0.9744751; … ; 0.40405852 0.4420395 … 0.12269497 0.18226653; 0.37383425 0.31592113 … 0.2997387 0.8113398], nothing, 10, 100, 5, nothing, nothing)</code></pre><p>The constructor for the data loader, when called on a matrix, also takes an optional argument <code>autoencoder</code>. If set to true than the data loader assumes we are dealing with an <em>autoencoder problem</em> and the field <code>n_params</code> in the <code>DataLoader</code> object will be set to the number of columns of our input matrix.  If <code>autoencoder=false</code>, then the field <code>input_time_steps</code> of the <code>DataLoader</code> object will be set to the <em>number of columns minus 1</em>. This is because in this case the data are used to train a neural network integrator and we need to leave at least one time step after the last one free in order to have something that we can compare the prediction to.  So we have that for an input of form <span>$(z^{(0)}, \ldots, z^{(T)})$</span> <code>input_time_steps</code> is <span>$T$</span>. </p><pre><code class="language-julia hljs">SnapshotMatrix = rand(Float32, 10, 100)

dl = DataLoader(SnapshotMatrix; autoencoder=false)
dl.input_time_steps</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">99</code></pre><p><code>DataLoader</code> can also be called with a <code>NamedTuple</code> that has <code>q</code> and <code>p</code> as keys.</p><p>In this case the field <code>input_dim</code> of <code>DataLoader</code> is interpreted as the sum of the <span>$q$</span>- and <span>$p$</span>-dimensions, i.e. if <span>$q$</span> and <span>$p$</span> both evolve on <span>$\mathbb{R}^n$</span>, then <code>input_dim</code> is <span>$2n$</span>.</p><pre><code class="language-julia hljs">SymplecticSnapshotTensor = (q = rand(Float32, 10, 100, 5), p = rand(Float32, 10, 100, 5))

dl = DataLoader(SymplecticSnapshotTensor)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataLoader{Float32, @NamedTuple{q::Array{Float32, 3}, p::Array{Float32, 3}}, Nothing, GeometricMachineLearning.TimeSteps}((q = Float32[0.4635421 0.69201267 … 0.9539613 0.37623936; 0.4052456 0.8018702 … 0.8910692 0.44831455; … ; 0.15953976 0.40180272 … 0.96080476 0.83905625; 0.019478321 0.0873127 … 0.6210236 0.5554325;;; 0.69412047 0.074192286 … 0.5429196 0.89076966; 0.0039377213 0.19487321 … 0.97842145 0.81555617; … ; 0.76753694 0.79007465 … 0.07247853 0.45853484; 0.5387024 0.71490717 … 0.09782541 0.34371275;;; 0.043918192 0.14449704 … 0.30626857 0.062101364; 0.77061296 0.7218288 … 0.69443935 0.69852054; … ; 0.808186 0.8697061 … 0.1314041 0.81746304; 0.5603297 0.20800358 … 0.4272455 0.7189765;;; 0.0985257 0.018309295 … 0.105724335 0.78361726; 0.5361394 0.5977892 … 0.74443674 0.022159338; … ; 0.17170227 0.024296045 … 0.12199527 0.34760034; 0.35111886 0.11394364 … 0.31738824 0.4625991;;; 0.72428644 0.10336745 … 0.479164 0.20672524; 0.36132723 0.9184133 … 0.80894333 0.04312581; … ; 0.62691396 0.2063222 … 0.731969 0.55704814; 0.48915285 0.6739933 … 0.53385717 0.9685223], p = Float32[0.7876334 0.9014347 … 0.6863378 0.7814894; 0.4100557 0.15563035 … 0.07689428 0.08254135; … ; 0.12328994 0.75038373 … 0.98999846 0.21108419; 0.7750797 0.3892153 … 0.45045894 0.99327403;;; 0.4037841 0.16652483 … 0.025662363 0.3876388; 0.9274548 0.008975089 … 0.49070847 0.94140196; … ; 0.761971 0.24751449 … 0.2147128 0.139629; 0.8604513 0.44897306 … 0.14748079 0.5791539;;; 0.38546014 0.64118767 … 0.6673768 0.44170362; 0.547697 0.99029744 … 0.4857918 0.31229013; … ; 0.11175525 0.44367373 … 0.006321788 0.24325514; 0.8952655 0.4021836 … 0.72595125 0.5690735;;; 0.9633239 0.3736956 … 0.9371662 0.5053807; 0.3335132 0.8970387 … 0.9890495 0.5388099; … ; 0.440885 0.6602239 … 0.19138151 0.15853071; 0.5967896 0.12840068 … 0.33047295 0.90465784;;; 0.07193071 0.45992196 … 0.8870767 0.5663773; 0.014755845 0.060150325 … 0.13778174 0.27693546; … ; 0.41001022 0.47161388 … 0.9318725 0.2779703; 0.312755 0.16792786 … 0.8174577 0.5326378]), nothing, 20, 99, 5, nothing, 1)</code></pre><h2 id="Convenience-functions"><a class="docs-heading-anchor" href="#Convenience-functions">Convenience functions</a><a id="Convenience-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-functions" title="Permalink"></a></h2><p><code>Batch</code> is a struct with an associated functor that acts on an instance of <code>DataLoader</code>. </p><p>The constructor of <code>Batch</code> takes <code>batch_size</code> (an integer) as input argument. Optionally we can provide <code>seq_length</code> if we deal with time series data and want to draw batches of a certain <em>length</em> (i.e. a range contained in the second dimension of the input array).</p><p>For a snapshot matrix (or a <code>NamedTuple</code> of the form <code>(q=A, p=B)</code> where <code>A</code> and <code>B</code> are matrices), the functor for <code>Batch</code> is called on an instance of <code>DataLoader</code>. It then returns a tuple of batch indices: </p><ul><li>for <code>autoencoder=true</code>: <span>$(\mathcal{I}_1, \ldots, \mathcal{I}_{\lceil\mathtt{n\_params/batch\_size}\rceil})$</span>, where the index runs from 1 to the number of batches, which is the number of columns in the snapshot matrix divided by the batch size (rounded up).</li><li>for <code>autoencoder=false</code>: <span>$(\mathcal{I}_1, \ldots, \mathcal{I}_{\lceil\mathtt{dl.input\_time\_steps/batch\_size}\rceil})$</span>, where the index runs from 1 to the number of batches, which is the number of columns in the snapshot matrix (minus one) divided by the batch size (rounded up).</li></ul><pre><code class="language-julia hljs">matrix_data = rand(Float32, 2, 10)
dl = DataLoader(matrix_data)

batch = Batch(3)
batch(dl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([8, 10, 4], [6, 3, 5], [2, 7, 1], [9])</code></pre><p>This also works if the data are in <span>$qp$</span> form: </p><pre><code class="language-julia hljs">using GeometricMachineLearning # hide

qp_data = (q = rand(Float32, 2, 10), p = rand(Float32, 2, 10))
dl = DataLoader(qp_data; autoencoder=true)

batch = Batch(3)
batch(dl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([2, 3, 1], [8, 5, 10], [4, 9, 7], [6])</code></pre><pre><code class="language-julia hljs">using GeometricMachineLearning # hide

qp_data = (q = rand(Float32, 2, 10), p = rand(Float32, 2, 10))
dl = DataLoader(qp_data; autoencoder=false) # false is default

batch = Batch(3)
batch(dl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([8, 4, 3], [1, 5, 2], [6, 9, 7])</code></pre><p>Specifically the routines do the following: </p><ol><li><span>$\mathtt{n\_indices}\leftarrow \mathtt{n\_params}\lor\mathtt{input\_time\_steps}$</span> </li><li><span>$\mathtt{indices} \leftarrow \mathtt{shuffle}(\mathtt{1:\mathtt{n\_indices}})$</span></li><li><span>$\mathcal{I}_i \leftarrow \mathtt{indices[(i - 1)} \cdot \mathtt{batch\_size} + 1 \mathtt{:} i \cdot \mathtt{batch\_size]}\text{ for }i=1, \ldots, (\mathrm{last} -1)$</span></li><li><span>$\mathcal{I}_\mathtt{last} \leftarrow \mathtt{indices[}(\mathtt{n\_batches} - 1) \cdot \mathtt{batch\_size} + 1\mathtt{:end]}$</span></li></ol><p>Note that the routines are implemented in such a way that no two indices appear double. </p><h2 id="Sampling-from-a-tensor"><a class="docs-heading-anchor" href="#Sampling-from-a-tensor">Sampling from a tensor</a><a id="Sampling-from-a-tensor-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-from-a-tensor" title="Permalink"></a></h2><p>We can also sample tensor data.</p><pre><code class="language-julia hljs">using GeometricMachineLearning # hide

qp_data = (q = rand(Float32, 2, 8, 3), p = rand(Float32, 2, 8, 3))
dl = DataLoader(qp_data)

# also specify sequence length here
batch = Batch(4, 5)
batch(dl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([(2, 2), (1, 2), (2, 1), (1, 1)], [(2, 3), (1, 3)])</code></pre><p>Sampling from a tensor is done the following way (<span>$\mathcal{I}_i$</span> again denotes the batch indices for the <span>$i$</span>-th batch): </p><ol><li><span>$\mathtt{time\_indices} \leftarrow \mathtt{shuffle}(\mathtt{1:}(\mathtt{input\_time\_steps} - \mathtt{seq\_length})$</span></li><li><span>$\mathtt{parameter\_indices} \leftarrow \mathtt{shuffle}(\mathtt{1:n\_params})$</span></li><li><span>$\mathtt{complete\_indices} \leftarrow \mathtt{Iterators.product}(\mathtt{time\_indices}, \mathtt{parameter\_indices}) \mathtt{|&gt; collect |&gt; vec}$</span></li><li><span>$\mathcal{I}_i \leftarrow \mathtt{complete\_indices[}(i - 1) \cdot \mathtt{batch\_size} + 1 : i \cdot \mathtt{batch\_size]}\text{ for }i=1, \ldots, (\mathrm{last} -1)$</span></li><li><span>$\mathcal{I}_\mathrm{last} \leftarrow \mathtt{complete\_indices[}(\mathrm{last} - 1) \cdot \mathtt{batch\_size} + 1\mathtt{:end]}$</span></li></ol><p>This algorithm can be visualized the following way (here <code>batch_size = 4</code>):</p><object type="image/svg+xml" class="display-light-only" data=../../tikz/tensor_sampling.png></object><object type="image/svg+xml" class="display-dark-only" data=../../tikz/tensor_sampling_dark.png></object><p>Here the sampling is performed over the second axis (the <em>time step dimension</em>) and the third axis (the <em>parameter dimension</em>). Whereas each block has thickness 1 in the <span>$x$</span> direction (i.e. pertains to a single parameter), its length in the <span>$y$</span> direction is <code>seq_length</code>. In total we sample as many such blocks as the batch size is big. By construction those blocks are never the same throughout a training epoch but may intersect each other!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../layers/multihead_attention_layer/">« Multihead Attention</a><a class="docs-footer-nextpage" href="../snapshot_matrix/">Snapshot matrix &amp; tensor »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Thursday 7 March 2024 15:40">Thursday 7 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
