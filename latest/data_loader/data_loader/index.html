<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Routines · GeometricMachineLearning.jl</title><meta name="title" content="Routines · GeometricMachineLearning.jl"/><meta property="og:title" content="Routines · GeometricMachineLearning.jl"/><meta property="twitter:title" content="Routines · GeometricMachineLearning.jl"/><meta name="description" content="Documentation for GeometricMachineLearning.jl."/><meta property="og:description" content="Documentation for GeometricMachineLearning.jl."/><meta property="twitter:description" content="Documentation for GeometricMachineLearning.jl."/><meta property="og:url" content="https://juliagni.github.io/GeometricMachineLearning.jl/data_loader/data_loader/"/><meta property="twitter:url" content="https://juliagni.github.io/GeometricMachineLearning.jl/data_loader/data_loader/"/><link rel="canonical" href="https://juliagni.github.io/GeometricMachineLearning.jl/data_loader/data_loader/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="GeometricMachineLearning.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="GeometricMachineLearning.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Architectures</span><ul><li><a class="tocitem" href="../../architectures/sympnet/">SympNet</a></li><li><a class="tocitem" href="../../architectures/symplectic_autoencoder/">Symplectic Autoencoders</a></li></ul></li><li><span class="tocitem">Manifolds</span><ul><li><a class="tocitem" href="../../manifolds/basic_topology/">Concepts from General Topology</a></li><li><a class="tocitem" href="../../manifolds/manifolds/">General Theory on Manifolds</a></li><li><a class="tocitem" href="../../manifolds/inverse_function_theorem/">The Inverse Function Theorem</a></li><li><a class="tocitem" href="../../manifolds/submersion_theorem/">The Submersion Theorem</a></li><li><a class="tocitem" href="../../manifolds/homogeneous_spaces/">Homogeneous Spaces</a></li><li><a class="tocitem" href="../../manifolds/stiefel_manifold/">Stiefel</a></li><li><a class="tocitem" href="../../manifolds/grassmann_manifold/">Grassmann</a></li><li><a class="tocitem" href="../../manifolds/existence_and_uniqueness_theorem/">Differential Equations and the EAU theorem</a></li></ul></li><li><span class="tocitem">Arrays</span><ul><li><a class="tocitem" href="../../arrays/skew_symmetric_matrix/">Symmetric and Skew-Symmetric Matrices</a></li><li><a class="tocitem" href="../../arrays/stiefel_lie_alg_horizontal/">Stiefel Global Tangent Space</a></li><li><a class="tocitem" href="../../arrays/grassmann_lie_alg_hor_matrix/">Grassmann Global Tangent Space</a></li></ul></li><li><span class="tocitem">Optimizer Framework</span><ul><li><a class="tocitem" href="../../Optimizer/">Optimizers</a></li><li><a class="tocitem" href="../../optimizers/general_optimization/">General Optimization</a></li><li><a class="tocitem" href="../../pullbacks/computation_of_pullbacks/">Pullbacks</a></li></ul></li><li><span class="tocitem">Optimizer Functions</span><ul><li><a class="tocitem" href="../../optimizers/manifold_related/horizontal_lift/">Horizontal Lift</a></li><li><a class="tocitem" href="../../optimizers/manifold_related/global_sections/">Global Sections</a></li><li><a class="tocitem" href="../../optimizers/manifold_related/retractions/">Retractions</a></li><li><a class="tocitem" href="../../optimizers/manifold_related/geodesic/">Geodesic Retraction</a></li><li><a class="tocitem" href="../../optimizers/manifold_related/cayley/">Cayley Retraction</a></li><li><a class="tocitem" href="../../optimizers/adam_optimizer/">Adam Optimizer</a></li><li><a class="tocitem" href="../../optimizers/bfgs_optimizer/">BFGS Optimizer</a></li></ul></li><li><span class="tocitem">Special Neural Network Layers</span><ul><li><a class="tocitem" href="../../layers/volume_preserving_feedforward/">Volume-Preserving Layers</a></li><li><a class="tocitem" href="../../layers/attention_layer/">Attention</a></li><li><a class="tocitem" href="../../layers/multihead_attention_layer/">Multihead Attention</a></li></ul></li><li><span class="tocitem">Data Loader</span><ul><li class="is-active"><a class="tocitem" href>Routines</a><ul class="internal"><li><a class="tocitem" href="#The-Batch-struct"><span>The <code>Batch</code> struct</span></a></li><li><a class="tocitem" href="#Sampling-from-a-tensor"><span>Sampling from a tensor</span></a></li></ul></li><li><a class="tocitem" href="../snapshot_matrix/">Snapshot matrix &amp; tensor</a></li></ul></li><li><span class="tocitem">Reduced Order Modelling</span><ul><li><a class="tocitem" href="../../reduced_order_modeling/autoencoder/">POD and Autoencoders</a></li><li><a class="tocitem" href="../../reduced_order_modeling/symplectic_autoencoder/">PSD and Symplectic Autoencoders</a></li><li><a class="tocitem" href="../../reduced_order_modeling/kolmogorov_n_width/">Kolmogorov n-width</a></li><li><a class="tocitem" href="../../reduced_order_modeling/projection_reduction_errors/">Projection and Reduction Error</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/sympnet_tutorial/">Sympnets</a></li><li><a class="tocitem" href="../../tutorials/symplectic_autoencoder/">Symplectic Autoencoders</a></li><li><a class="tocitem" href="../../tutorials/mnist_tutorial/">MNIST</a></li><li><a class="tocitem" href="../../tutorials/grassmann_layer/">Grassmann manifold</a></li><li><a class="tocitem" href="../../tutorials/volume_preserving_attention/">Volume-Preserving Attention</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Data Loader</a></li><li class="is-active"><a href>Routines</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Routines</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGNI/GeometricMachineLearning.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGNI/GeometricMachineLearning.jl/blob/main/docs/src/data_loader/data_loader.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-Loader"><a class="docs-heading-anchor" href="#Data-Loader">Data Loader</a><a id="Data-Loader-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Loader" title="Permalink"></a></h1><p>Data Loader is a struct that creates an instance based on a tensor (or different input format) and is designed to make training convenient. </p><h2>Constructor</h2><p>The data loader can be called with various inputs:</p><ul><li><strong>A single vector</strong>: If the data loader is called with a single vector (and no other arguments are given), then this is interpreted as an autoencoder problem, i.e. the second axis indicates parameter values and/or time steps and the system has a single degree of freedom (i.e. the system dimension is one).</li><li><strong>A single matrix</strong>: If the data loader is called with a single matrix (and no other arguments are given), then this is interpreted as an autoencoder problem, i.e. the first axis is assumed to indicate the degrees of freedom of the system and the second axis indicates parameter values and/or time steps. </li><li><strong>A single tensor</strong>: If the data loader is called with a single tensor, then this is interpreted as an <em>integration problem</em> with the second axis indicating the time step and the third one indicating the parameters.</li><li><strong>A tensor and a vector</strong>: This is a special case (MNIST classification problem). For the MNIST problem for example the input are <span>$n_p$</span> matrices (first input argument) and <span>$n_p$</span> integers (second input argument).</li><li><strong>A <code>NamedTuple</code> with fields <code>q</code> and <code>p</code></strong>: The <code>NamedTuple</code> contains (i) two matrices or (ii) two tensors. </li><li><strong>An <code>EnsembleSolution</code></strong>: The <code>EnsembleSolution</code> typically comes from <code>GeometricProblems</code>.</li></ul><p>When we supply a single vector or a single matrix as input to <code>DataLoader</code> and further set <code>autoencoder = false</code> (keyword argument), then the data are stored as an <em>integration problem</em> and the second axis is assumed to indicate time steps.</p><p>The data loader can be called with various types of arrays as input, for example a <a href="../snapshot_matrix/">snapshot matrix</a>:</p><pre><code class="language-julia hljs">SnapshotMatrix = rand(Float32, 10, 100)

dl = DataLoader(SnapshotMatrix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataLoader{Float32, Array{Float32, 3}, Nothing, :RegularData}(Float32[0.8816791; 0.1122663; … ; 0.8344472; 0.7103157;;; 0.9725146; 0.6775526; … ; 0.9940152; 0.1986509;;; 0.4050905; 0.82398885; … ; 0.41764784; 0.7036106;;; … ;;; 0.22671288; 0.9567553; … ; 0.68623894; 0.6131638;;; 0.51357734; 0.39018548; … ; 0.88342655; 0.40068877;;; 0.4377458; 0.30666727; … ; 0.8875937; 0.53051174], nothing, 10, 1, 100, nothing, nothing)</code></pre><p>or a snapshot tensor: </p><pre><code class="language-julia hljs">SnapshotTensor = rand(Float32, 10, 100, 5)

dl = DataLoader(SnapshotTensor)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataLoader{Float32, Array{Float32, 3}, Nothing, :TimeSeries}(Float32[0.8726474 0.02400291 … 0.07830399 0.5990119; 0.8493774 0.54486567 … 0.8987287 0.629413; … ; 0.28285748 0.19329023 … 0.040736556 0.61005676; 0.12845343 0.053248525 … 0.54802567 0.3389467;;; 0.9845983 0.7013776 … 0.8872254 0.12759453; 0.82346517 0.2857691 … 0.68641716 0.102670014; … ; 0.5763357 0.5121253 … 0.94178396 0.88397336; 0.13942641 0.2167269 … 0.71882087 0.76764786;;; 0.111478746 0.04436922 … 0.60635453 0.65084374; 0.8968833 0.46727628 … 0.15800148 0.02270174; … ; 0.3403166 0.066996336 … 0.5660242 0.9464898; 0.43928194 0.8144903 … 0.45254493 0.6348514;;; 0.8831519 0.07297188 … 0.12928063 0.6884582; 0.55788493 0.19795746 … 0.32025772 0.5028009; … ; 0.18631732 0.5180662 … 0.30729663 0.93314415; 0.15481943 0.6792206 … 0.57724905 0.13477117;;; 0.735543 0.31147552 … 0.5999477 0.5780203; 0.32424265 0.88551545 … 0.030725718 0.37763917; … ; 0.5770998 0.42351305 … 0.31962955 0.8900493; 0.90180993 0.56742734 … 0.9176935 0.39691198], nothing, 10, 100, 5, nothing, nothing)</code></pre><p>Here the <code>DataLoader</code> has different properties <code>:RegularData</code> and <code>:TimeSeries</code>. This indicates that in the first case we treat all columns in the input tensor independently (this is mostly used for autoencoder problems), whereas in the second case we have <em>time series-like data</em>, which are mostly used for integration problems.  We can also treat a problem with a matrix as input as a time series-like problem by providing an additional keyword argument: <code>autoencoder=false</code>:</p><pre><code class="language-julia hljs">SnapshotMatrix = rand(Float32, 10, 100)

dl = DataLoader(SnapshotMatrix; autoencoder=false)
dl.input_time_steps</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100</code></pre><p><code>DataLoader</code> can also be called with a <code>NamedTuple</code> that has <code>q</code> and <code>p</code> as keys.</p><p>In this case the field <code>input_dim</code> of <code>DataLoader</code> is interpreted as the sum of the <span>$q$</span>- and <span>$p$</span>-dimensions, i.e. if <span>$q$</span> and <span>$p$</span> both evolve on <span>$\mathbb{R}^n$</span>, then <code>input_dim</code> is <span>$2n$</span>.</p><pre><code class="language-julia hljs">SymplecticSnapshotTensor = (q = rand(Float32, 10, 100, 5), p = rand(Float32, 10, 100, 5))

dl = DataLoader(SymplecticSnapshotTensor)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataLoader{Float32, @NamedTuple{q::Array{Float32, 3}, p::Array{Float32, 3}}, Nothing, :TimeSeries}((q = Float32[0.35040987 0.8347963 … 0.041808784 0.008362591; 0.4419564 0.34296 … 0.3073728 0.6745612; … ; 0.16084135 0.62792903 … 0.1390847 0.28544205; 0.3198524 0.5908062 … 0.35244924 0.5961917;;; 0.77633566 0.13739532 … 0.99480855 0.1499837; 0.76945275 0.5760269 … 0.89266104 0.030425072; … ; 0.39562446 0.649889 … 0.2129935 0.97698015; 0.80123925 0.12773013 … 0.7201405 0.87574404;;; 0.15805352 0.89323103 … 0.4100818 0.9684389; 0.47224325 0.703215 … 0.13554531 0.13392323; … ; 0.48934776 0.27389258 … 0.21064866 0.695282; 0.54344505 0.9875192 … 0.47415853 0.3463549;;; 0.305364 0.4234224 … 0.72404504 0.5658888; 0.18922794 0.21254343 … 0.3688715 0.114932954; … ; 0.8375095 0.59577984 … 0.13811642 0.33326256; 0.20402294 0.37967825 … 0.9815317 0.112446606;;; 0.26911497 0.9783254 … 0.5075099 0.40313375; 0.9788402 0.9274734 … 0.98001164 0.05493915; … ; 0.14574158 0.6796964 … 0.6048863 0.22050983; 0.036302805 0.3506084 … 0.025508046 0.26780623], p = Float32[0.46014792 0.6973303 … 0.1544776 0.3054207; 0.0877102 0.83898234 … 0.24648285 0.4073788; … ; 0.8104954 0.73036194 … 0.60169184 0.99656606; 0.5908182 0.5074435 … 0.47576648 0.3911267;;; 0.66102815 0.9544848 … 0.4539199 0.18346697; 0.113211334 0.90965354 … 0.8263025 0.5956385; … ; 0.9218498 0.8868526 … 0.36591196 0.80890524; 0.65899426 0.698466 … 0.3780954 0.21936631;;; 0.97608805 0.63584995 … 0.11484629 0.12117982; 0.57085687 0.6901166 … 0.17609215 0.15980965; … ; 0.58198994 0.40107316 … 0.83832264 0.052236497; 0.7194586 0.093203664 … 0.09304881 0.58309793;;; 0.8722328 0.6769649 … 0.43004125 0.74051255; 0.8613387 0.8197563 … 0.84209144 0.85989624; … ; 0.81154853 0.7279547 … 0.41966492 0.24493676; 0.60078144 0.90652806 … 0.61219424 0.9542124;;; 0.28491676 0.7493724 … 0.86253685 0.54966617; 0.5007413 0.11234528 … 0.16477841 0.5072098; … ; 0.1548422 0.5227642 … 0.32496685 0.5893462; 0.7241845 0.4939415 … 0.8138076 0.5588328]), nothing, 20, 100, 5, nothing, nothing)</code></pre><pre><code class="language-julia hljs">dl.input_dim</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">20</code></pre><h2 id="The-Batch-struct"><a class="docs-heading-anchor" href="#The-Batch-struct">The <code>Batch</code> struct</a><a id="The-Batch-struct-1"></a><a class="docs-heading-anchor-permalink" href="#The-Batch-struct" title="Permalink"></a></h2><p><code>Batch</code> is a struct whose functor acts on an instance of <code>DataLoader</code> to produce a sequence of training samples for training for one epoch. </p><h2>The Constructor</h2><p>The constructor for <code>Batch</code> is called with: </p><ul><li><code>batch_size::Int</code></li><li><code>seq_length::Int</code> (optional)</li><li><code>prediction_window::Int</code> (optional)</li></ul><p>The first one of these arguments is required; it indicates the number of training samples in a batch. If we deal with time series data then we can additionaly supply a <em>sequence length</em> and a <em>prediction window</em> as input arguments to <code>Batch</code>. These indicate the number of input vectors and the number of output vectors.</p><h2>The functor</h2><p>An instance of <code>Batch</code> can be called on an instance of <code>DataLoader</code> to produce a sequence of samples that contain all the input data, i.e. for training for one epoch. The output of applying <code>batch:Batch</code> to <code>dl::DataLoader</code> is a tuple of vectors of integers. Each of these vectors contains two integers: the first is the <em>time index</em> and the second one is the <em>parameter index</em>.</p><pre><code class="language-julia hljs">matrix_data = rand(Float32, 2, 10)
dl = DataLoader(matrix_data; autoencoder = true)

batch = Batch(3)
batch(dl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([(1, 10), (1, 4), (1, 9)], [(1, 7), (1, 8), (1, 3)], [(1, 6), (1, 1), (1, 2)], [(1, 5)])</code></pre><p>This also works if the data are in <span>$qp$</span> form: </p><pre><code class="language-julia hljs">qp_data = (q = rand(Float32, 2, 10), p = rand(Float32, 2, 10))
dl = DataLoader(qp_data; autoencoder = true)

batch = Batch(3)
batch(dl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([(1, 3), (1, 9), (1, 6)], [(1, 4), (1, 2), (1, 7)], [(1, 10), (1, 8), (1, 5)], [(1, 1)])</code></pre><p>In those two examples the <code>autoencoder</code> keyword was set to <code>true</code> (the default). This is why the first index was always <code>1</code>. This changes if we set <code>autoencoder = false</code>: </p><pre><code class="language-julia hljs">qp_data = (q = rand(Float32, 2, 10), p = rand(Float32, 2, 10))
dl = DataLoader(qp_data; autoencoder = false) # false is default

batch = Batch(3)
batch(dl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([(1, 1), (5, 1), (6, 1)], [(8, 1), (3, 1), (9, 1)], [(4, 1), (7, 1), (2, 1)])</code></pre><p>Specifically the routines do the following: </p><ol><li><span>$\mathtt{n\_indices}\leftarrow \mathtt{n\_params}\lor\mathtt{input\_time\_steps},$</span> </li><li><span>$\mathtt{indices} \leftarrow \mathtt{shuffle}(\mathtt{1:\mathtt{n\_indices}}),$</span></li><li><span>$\mathcal{I}_i \leftarrow \mathtt{indices[(i - 1)} \cdot \mathtt{batch\_size} + 1 \mathtt{:} i \cdot \mathtt{batch\_size]}\text{ for }i=1, \ldots, (\mathrm{last} -1),$</span></li><li><span>$\mathcal{I}_\mathtt{last} \leftarrow \mathtt{indices[}(\mathtt{n\_batches} - 1) \cdot \mathtt{batch\_size} + 1\mathtt{:end]}.$</span></li></ol><p>Note that the routines are implemented in such a way that no two indices appear double. </p><h2 id="Sampling-from-a-tensor"><a class="docs-heading-anchor" href="#Sampling-from-a-tensor">Sampling from a tensor</a><a id="Sampling-from-a-tensor-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-from-a-tensor" title="Permalink"></a></h2><p>We can also sample tensor data.</p><pre><code class="language-julia hljs">qp_data = (q = rand(Float32, 2, 20, 3), p = rand(Float32, 2, 20, 3))
dl = DataLoader(qp_data)

# also specify sequence length here
batch = Batch(4, 5)
batch(dl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([(8, 1), (5, 1), (7, 1), (9, 1)], [(1, 1), (2, 1), (10, 1), (6, 1)], [(11, 1), (3, 1), (4, 1), (8, 2)], [(5, 2), (7, 2), (9, 2), (1, 2)], [(2, 2), (10, 2), (6, 2), (11, 2)], [(3, 2), (4, 2), (8, 3), (5, 3)], [(7, 3), (9, 3), (1, 3), (2, 3)], [(10, 3), (6, 3), (11, 3), (3, 3)], [(4, 3)])</code></pre><p>Sampling from a tensor is done the following way (<span>$\mathcal{I}_i$</span> again denotes the batch indices for the <span>$i$</span>-th batch): </p><ol><li><span>$\mathtt{time\_indices} \leftarrow \mathtt{shuffle}(\mathtt{1:}(\mathtt{input\_time\_steps} - \mathtt{seq\_length} - \mathtt{prediction_window}),$</span></li><li><span>$\mathtt{parameter\_indices} \leftarrow \mathtt{shuffle}(\mathtt{1:n\_params}),$</span></li><li><span>$\mathtt{complete\_indices} \leftarrow \mathtt{product}(\mathtt{time\_indices}, \mathtt{parameter\_indices}),$</span></li><li><span>$\mathcal{I}_i \leftarrow \mathtt{complete\_indices[}(i - 1) \cdot \mathtt{batch\_size} + 1 : i \cdot \mathtt{batch\_size]}\text{ for }i=1, \ldots, (\mathrm{last} -1),$</span></li><li><span>$\mathcal{I}_\mathrm{last} \leftarrow \mathtt{complete\_indices[}(\mathrm{last} - 1) \cdot \mathtt{batch\_size} + 1\mathtt{:end]}.$</span></li></ol><p>This algorithm can be visualized the following way (here <code>batch_size = 4</code>):</p><object type="image/svg+xml" class="display-light-only" data=../../tikz/tensor_sampling.png></object><object type="image/svg+xml" class="display-dark-only" data=../../tikz/tensor_sampling_dark.png></object><p>Here the sampling is performed over the second axis (the <em>time step dimension</em>) and the third axis (the <em>parameter dimension</em>). Whereas each block has thickness 1 in the <span>$x$</span> direction (i.e. pertains to a single parameter), its length in the <span>$y$</span> direction is <code>seq_length</code>. In total we sample as many such blocks as the batch size is big. By construction those blocks are never the same throughout a training epoch but may intersect each other!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../layers/multihead_attention_layer/">« Multihead Attention</a><a class="docs-footer-nextpage" href="../snapshot_matrix/">Snapshot matrix &amp; tensor »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 13 May 2024 15:03">Monday 13 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
