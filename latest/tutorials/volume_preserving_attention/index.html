<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Volume-Preserving Attention · GeometricMachineLearning.jl</title><meta name="title" content="Volume-Preserving Attention · GeometricMachineLearning.jl"/><meta property="og:title" content="Volume-Preserving Attention · GeometricMachineLearning.jl"/><meta property="twitter:title" content="Volume-Preserving Attention · GeometricMachineLearning.jl"/><meta name="description" content="Documentation for GeometricMachineLearning.jl."/><meta property="og:description" content="Documentation for GeometricMachineLearning.jl."/><meta property="twitter:description" content="Documentation for GeometricMachineLearning.jl."/><meta property="og:url" content="https://juliagni.github.io/GeometricMachineLearning.jl/tutorials/volume_preserving_attention/"/><meta property="twitter:url" content="https://juliagni.github.io/GeometricMachineLearning.jl/tutorials/volume_preserving_attention/"/><link rel="canonical" href="https://juliagni.github.io/GeometricMachineLearning.jl/tutorials/volume_preserving_attention/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="GeometricMachineLearning.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="GeometricMachineLearning.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Architectures</span><ul><li><a class="tocitem" href="../../architectures/sympnet/">SympNet</a></li></ul></li><li><span class="tocitem">Manifolds</span><ul><li><a class="tocitem" href="../../manifolds/basic_topology/">Concepts from General Topology</a></li><li><a class="tocitem" href="../../manifolds/manifolds/">General Theory on Manifolds</a></li><li><a class="tocitem" href="../../manifolds/inverse_function_theorem/">The Inverse Function Theorem</a></li><li><a class="tocitem" href="../../manifolds/submersion_theorem/">The Submersion Theorem</a></li><li><a class="tocitem" href="../../manifolds/homogeneous_spaces/">Homogeneous Spaces</a></li><li><a class="tocitem" href="../../manifolds/stiefel_manifold/">Stiefel</a></li><li><a class="tocitem" href="../../manifolds/grassmann_manifold/">Grassmann</a></li><li><a class="tocitem" href="../../manifolds/existence_and_uniqueness_theorem/">Differential Equations and the EAU theorem</a></li></ul></li><li><span class="tocitem">Arrays</span><ul><li><a class="tocitem" href="../../arrays/skew_symmetric_matrix/">Symmetric and Skew-Symmetric Matrices</a></li><li><a class="tocitem" href="../../arrays/stiefel_lie_alg_horizontal/">Stiefel Global Tangent Space</a></li><li><a class="tocitem" href="../../arrays/grassmann_lie_alg_hor_matrix/">Grassmann Global Tangent Space</a></li></ul></li><li><span class="tocitem">Optimizer Framework</span><ul><li><a class="tocitem" href="../../Optimizer/">Optimizers</a></li><li><a class="tocitem" href="../../optimizers/general_optimization/">General Optimization</a></li><li><a class="tocitem" href="../../pullbacks/computation_of_pullbacks/">Pullbacks</a></li></ul></li><li><span class="tocitem">Optimizer Functions</span><ul><li><a class="tocitem" href="../../optimizers/manifold_related/horizontal_lift/">Horizontal Lift</a></li><li><a class="tocitem" href="../../optimizers/manifold_related/global_sections/">Global Sections</a></li><li><a class="tocitem" href="../../optimizers/manifold_related/retractions/">Retractions</a></li><li><a class="tocitem" href="../../optimizers/manifold_related/geodesic/">Geodesic Retraction</a></li><li><a class="tocitem" href="../../optimizers/manifold_related/cayley/">Cayley Retraction</a></li><li><a class="tocitem" href="../../optimizers/adam_optimizer/">Adam Optimizer</a></li><li><a class="tocitem" href="../../optimizers/bfgs_optimizer/">BFGS Optimizer</a></li></ul></li><li><span class="tocitem">Special Neural Network Layers</span><ul><li><a class="tocitem" href="../../layers/volume_preserving_feedforward/">Volume-Preserving Layers</a></li><li><a class="tocitem" href="../../layers/attention_layer/">Attention</a></li><li><a class="tocitem" href="../../layers/multihead_attention_layer/">Multihead Attention</a></li></ul></li><li><span class="tocitem">Data Loader</span><ul><li><a class="tocitem" href="../../data_loader/data_loader/">Routines</a></li><li><a class="tocitem" href="../../data_loader/snapshot_matrix/">Snapshot matrix &amp; tensor</a></li></ul></li><li><span class="tocitem">Reduced Order Modelling</span><ul><li><a class="tocitem" href="../../reduced_order_modeling/autoencoder/">POD and Autoencoders</a></li><li><a class="tocitem" href="../../reduced_order_modeling/symplectic_autoencoder/">PSD and Symplectic Autoencoders</a></li><li><a class="tocitem" href="../../reduced_order_modeling/kolmogorov_n_width/">Kolmogorov n-width</a></li><li><a class="tocitem" href="../../reduced_order_modeling/projection_reduction_errors/">Projection and Reduction Error</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../sympnet_tutorial/">Sympnets</a></li><li><a class="tocitem" href="../linear_wave_equation/">Linear Wave Equation</a></li><li><a class="tocitem" href="../mnist_tutorial/">MNIST</a></li><li><a class="tocitem" href="../grassmann_layer/">Grassmann manifold</a></li><li class="is-active"><a class="tocitem" href>Volume-Preserving Attention</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Volume-Preserving Attention</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Volume-Preserving Attention</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGNI/GeometricMachineLearning.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGNI/GeometricMachineLearning.jl/blob/main/docs/src/tutorials/volume_preserving_attention.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Comparison-of-different-VolumePreservingAttention"><a class="docs-heading-anchor" href="#Comparison-of-different-VolumePreservingAttention">Comparison of different <code>VolumePreservingAttention</code></a><a id="Comparison-of-different-VolumePreservingAttention-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-of-different-VolumePreservingAttention" title="Permalink"></a></h1><p>In the <a href="../../layers/attention_layer/">section of volume-preserving attention</a> we mentioned two ways of computing volume-preserving attention: one where we compute the correlations with a skew-symmetric matrix and one where we compute the correlations with an arbitrary matrix. Here we compare the two approaches. When calling the <code>VolumePreservingAttention</code> layer we can specify whether we want to use the skew-symmetric or the arbitrary weighting by setting the keyword <code>skew_sym = true</code> and <code>skew_sym = false</code> respectively. </p><p>In here we demonstrate the differences between the two approaches for computing correlations. For this we first generate a training set consisting of two collections of curves: (i) sine curves and (ii) cosine curve. </p><pre><code class="language-julia hljs">import Random # hide

sine_cosine = zeros(1, 1000, 2)
sine_cosine[1, :, 1] .= sin.(0.:.1:99.9)
sine_cosine[1, :, 2] .= cos.(0.:.1:99.9)


const dl = DataLoader(Float16.(sine_cosine))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataLoader{Float16, Array{Float16, 3}, Nothing, :TimeSeries}(Float16[0.0 0.09985 … -0.6675 -0.59;;; 1.0 0.995 … 0.7446 0.8076], nothing, 1, 1000, 2, nothing, nothing)</code></pre><p>The third axis (i.e. the parameter axis) has length two, meaning we have two different kinds of curves: </p><pre><code class="language-julia hljs">plot(dl.input[1, :, 1], label = &quot;sine&quot;)
plot!(dl.input[1, :, 2], label = &quot;cosine&quot;)</code></pre><img src="18e19caf.svg" alt="Example block output"/><p>We want to train a single neural network on both these curves. We compare three networks which are of the following form: </p><p class="math-container">\[\mathtt{network} = \mathcal{NN}_d\circ\Psi\circ\mathcal{NN}_u,\]</p><p>where <span>$\mathcal{NN}_u$</span> refers to a neural network that scales up and <span>$\mathcal{NN}_d$</span> refers to a neural network that scales down. The up and down scaling is done with simple dense layers: </p><p class="math-container">\[\mathcal{NN}_u(x) = \mathrm{tanh}(a_ux + b_u) \text{ and } \mathcal{NN}_d(x) = a_d^Tx + b_d,\]</p><p>where <span>$a_u, b_u, a_d\in\mathbb{R}^\mathrm{ud}$</span> and <span>$b_d$</span> is a scalar. <code>ud</code> refers to <em>upscaling dimension</em>. For <span>$\Psi$</span> we consider three different choices:</p><ol><li>a volume-preserving attention with skew-symmetric weighting,</li><li>a volume-preserving attention with arbitrary weighting,</li><li>an identity layer.</li></ol><p>We further choose a sequence length 5 (i.e. the network always sees the last 5 time steps) and always predict one step into the future (i.e. the prediction window is set to 1):</p><pre><code class="language-julia hljs">const seq_length = 3
const prediction_window = 1

const upscale_dimension_1 = 2

const T = Float16

function set_up_networks(upscale_dimension::Int = upscale_dimension_1)
    model_skew = Chain(Dense(1, upscale_dimension, tanh), VolumePreservingAttention(upscale_dimension, seq_length; skew_sym = true),  Dense(upscale_dimension, 1, identity; use_bias = true))
    model_arb  = Chain(Dense(1, upscale_dimension, tanh), VolumePreservingAttention(upscale_dimension, seq_length; skew_sym = false), Dense(upscale_dimension, 1, identity; use_bias = true))
    model_comp = Chain(Dense(1, upscale_dimension, tanh), Dense(upscale_dimension, 1, identity; use_bias = true))

    nn_skew = NeuralNetwork(model_skew, CPU(), T)
    nn_arb  = NeuralNetwork(model_arb,  CPU(), T)
    nn_comp = NeuralNetwork(model_comp, CPU(), T)

    nn_skew, nn_arb, nn_comp
end

nn_skew, nn_arb, nn_comp = set_up_networks()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(NeuralNetwork{AbstractNeuralNetworks.UnknownArchitecture, Chain{Tuple{Dense{1, 2, true, typeof(tanh)}, VolumePreservingAttention{2, 2, :skew_sym, 3}, Dense{2, 1, true, typeof(identity)}}}, Tuple{@NamedTuple{W::Matrix{Float16}, b::Vector{Float16}}, @NamedTuple{A::SkewSymMatrix{Float16, Vector{Float16}}}, @NamedTuple{W::Matrix{Float16}, b::Vector{Float16}}}, CPU}(AbstractNeuralNetworks.UnknownArchitecture(), Chain{Tuple{Dense{1, 2, true, typeof(tanh)}, VolumePreservingAttention{2, 2, :skew_sym, 3}, Dense{2, 1, true, typeof(identity)}}}((Dense{1, 2, true, typeof(tanh)}(tanh), VolumePreservingAttention{2, 2, :skew_sym, 3}(), Dense{2, 1, true, typeof(identity)}(identity))), ((W = Float16[-0.6455; -1.463;;], b = Float16[-1.624, -0.2177]), (A = Float16[0.0 -0.1244; 0.1244 0.0],), (W = Float16[0.981 0.07996], b = Float16[1.549])), CPU(false)), NeuralNetwork{AbstractNeuralNetworks.UnknownArchitecture, Chain{Tuple{Dense{1, 2, true, typeof(tanh)}, VolumePreservingAttention{2, 2, :arbitrary, 3}, Dense{2, 1, true, typeof(identity)}}}, Tuple{@NamedTuple{W::Matrix{Float16}, b::Vector{Float16}}, @NamedTuple{A::Matrix{Float16}}, @NamedTuple{W::Matrix{Float16}, b::Vector{Float16}}}, CPU}(AbstractNeuralNetworks.UnknownArchitecture(), Chain{Tuple{Dense{1, 2, true, typeof(tanh)}, VolumePreservingAttention{2, 2, :arbitrary, 3}, Dense{2, 1, true, typeof(identity)}}}((Dense{1, 2, true, typeof(tanh)}(tanh), VolumePreservingAttention{2, 2, :arbitrary, 3}(), Dense{2, 1, true, typeof(identity)}(identity))), ((W = Float16[-1.342; 0.412;;], b = Float16[0.5933, -0.7686]), (A = Float16[-1.125 -0.3372; -0.0861 -0.9746],), (W = Float16[0.206 -1.019], b = Float16[0.5054])), CPU(false)), NeuralNetwork{AbstractNeuralNetworks.UnknownArchitecture, Chain{Tuple{Dense{1, 2, true, typeof(tanh)}, Dense{2, 1, true, typeof(identity)}}}, Tuple{@NamedTuple{W::Matrix{Float16}, b::Vector{Float16}}, @NamedTuple{W::Matrix{Float16}, b::Vector{Float16}}}, CPU}(AbstractNeuralNetworks.UnknownArchitecture(), Chain{Tuple{Dense{1, 2, true, typeof(tanh)}, Dense{2, 1, true, typeof(identity)}}}((Dense{1, 2, true, typeof(tanh)}(tanh), Dense{2, 1, true, typeof(identity)}(identity))), ((W = Float16[-0.538; 0.2615;;], b = Float16[-1.312, -1.275]), (W = Float16[0.3884 0.109], b = Float16[0.2737])), CPU(false)))</code></pre><p>We expect the third network to not be able to learn anything useful since it cannot resolve time series data: a regular feedforward network only ever sees one datum at a time. </p><p>Next we train the networks (here we pick a batch size of 30):</p><pre><code class="language-julia hljs">function set_up_optimizers(nn_skew, nn_arb, nn_comp)
    o_skew = Optimizer(AdamOptimizer(T), nn_skew)
    o_arb  = Optimizer(AdamOptimizer(T), nn_arb)
    o_comp = Optimizer(AdamOptimizer(T), nn_comp)

    o_skew, o_arb, o_comp
end

o_skew, o_arb, o_comp = set_up_optimizers(nn_skew, nn_arb, nn_comp)

const n_epochs = 1000

const batch_size = 30

const batch = Batch(batch_size, seq_length, prediction_window)
const batch2 = Batch(batch_size)

function train_networks!(nn_skew, nn_arb, nn_comp)
    loss_array_skew = o_skew(nn_skew, dl, batch, n_epochs, TransformerLoss(batch))
    loss_array_arb  = o_arb( nn_arb,  dl, batch, n_epochs, TransformerLoss(batch))
    loss_array_comp = o_comp(nn_comp, dl, batch2, n_epochs, FeedForwardLoss())

    loss_array_skew, loss_array_arb, loss_array_comp
end

loss_array_skew, loss_array_arb, loss_array_comp = train_networks!(nn_skew, nn_arb, nn_comp)

function plot_training_losses(loss_array_skew, loss_array_arb, loss_array_comp)
    p = plot(loss_array_skew, color = 2, label = &quot;skew&quot;, yaxis = :log)
    plot!(p, loss_array_arb,  color = 3, label = &quot;arb&quot;)
    plot!(p, loss_array_comp, color = 4, label = &quot;comp&quot;)

    p
end

plot_training_losses(loss_array_skew, loss_array_arb, loss_array_comp)</code></pre><img src="b16c3254.svg" alt="Example block output"/><p>Looking at the training errors, we can see that the network with the skew-symmetric weighting is stuck at a relatively high error rate, whereas the loss for  the network with the arbitrary weighting is decreasing to a significantly lower level. The feedforward network without the attention mechanism is not able to learn anything useful (as was expected). </p><p>The following demonstrates the predictions of our approaches<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>: </p><pre><code class="language-julia hljs">initial_condition = dl.input[:, 1:seq_length, 2]

function make_networks_neural_network_integrators(nn_skew, nn_arb, nn_comp)
    nn_skew = NeuralNetwork(GeometricMachineLearning.DummyTransformer(seq_length), nn_skew.model, nn_skew.params, CPU())
    nn_arb  = NeuralNetwork(GeometricMachineLearning.DummyTransformer(seq_length), nn_arb.model,  nn_arb.params, CPU())
    nn_comp = NeuralNetwork(GeometricMachineLearning.DummyNNIntegrator(), nn_comp.model, nn_comp.params, CPU())

    nn_skew, nn_arb, nn_comp
end

nn_skew, nn_arb, nn_comp = make_networks_neural_network_integrators(nn_skew, nn_arb, nn_comp)

function produce_validation_plot(n_points::Int, nn_skew = nn_skew, nn_arb = nn_arb, nn_comp = nn_comp; initial_condition::Matrix=initial_condition, type = :cos)
    validation_skew = iterate(nn_skew, initial_condition; n_points = n_points, prediction_window = 1)
    validation_arb  = iterate(nn_arb,  initial_condition; n_points = n_points, prediction_window = 1)
    validation_comp = iterate(nn_comp, initial_condition[:, 1]; n_points = n_points)

    p2 = type == :cos ? plot(dl.input[1, 1:n_points, 2], color = 1, label = &quot;reference&quot;) : plot(dl.input[1, 1:n_points, 1], color = 1, label = &quot;reference&quot;)

    plot!(validation_skew[1, :], color = 2, label = &quot;skew&quot;)
    plot!(p2, validation_arb[1, :], color = 3, label = &quot;arb&quot;)
    plot!(p2, validation_comp[1, :], color = 4, label = &quot;comp&quot;)
    vline!([seq_length], color = :red, label = &quot;start of prediction&quot;)

    p2
end

p2 = produce_validation_plot(40)</code></pre><img src="2b187a5c.svg" alt="Example block output"/><p>In the above plot we can see that the network with the arbitrary weighting performs much better; even though the green line does not fit the blue line very well either, it manages to least qualitatively reflect the training data.  We can also plot the predictions for longer time intervals: </p><pre><code class="language-julia hljs">p3 = produce_validation_plot(400)</code></pre><img src="3abe48a2.svg" alt="Example block output"/><p>We can also plot the comparison with the sine function: </p><pre><code class="language-julia hljs">initial_condition = dl.input[:, 1:seq_length, 1]

p2 = produce_validation_plot(40, initial_condition = initial_condition, type = :sin)</code></pre><img src="8164803a.svg" alt="Example block output"/><p>This advantage of the volume-preserving attention with arbitrary weighting may however be due to the fact that the skew-symmetric attention only has 3 learnable parameters, as opposed to 9 for the arbitrary weighting. If we increase the <em>upscaling dimension</em> the result changes: </p><pre><code class="language-julia hljs">const upscale_dimension_2 = 10

nn_skew, nn_arb, nn_comp = set_up_networks(upscale_dimension_2)

o_skew, o_arb, o_comp = set_up_optimizers(nn_skew, nn_arb, nn_comp)

loss_array_skew, loss_array_arb, loss_array_comp = train_networks!(nn_skew, nn_arb, nn_comp)

plot_training_losses(loss_array_skew, loss_array_arb, loss_array_comp)</code></pre><img src="984193ed.svg" alt="Example block output"/><pre><code class="language-julia hljs">initial_condition = dl.input[:, 1:seq_length, 2]

nn_skew, nn_arb, nn_comp = make_networks_neural_network_integrators(nn_skew, nn_arb, nn_comp)

p2 = produce_validation_plot(40, nn_skew, nn_arb, nn_comp)</code></pre><img src="2d2abbe4.svg" alt="Example block output"/><p>And for a longer time interval: </p><pre><code class="language-julia hljs">p3 = produce_validation_plot(200, nn_skew, nn_arb, nn_comp)</code></pre><img src="8ea2a23b.svg" alt="Example block output"/><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Here we have to use the architectures <code>DummyTransformer</code> and <code>DummyNNIntegrator</code> to reformulate the three neural networks defined here as <code>NeuralNetworkIntegrator</code>s. Normally the user should try to use predefined architectures in <code>GeometricMachineLearning</code>, that way they never use <code>DummyTransformer</code> and <code>DummyNNIntegrator</code>. </li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../grassmann_layer/">« Grassmann manifold</a><a class="docs-footer-nextpage" href="../../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 2 May 2024 11:37">Thursday 2 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
